<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ESL City Direction Tool</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background-color: #f0f4f8;
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 20px;
            }

            h1 {
                color: #2c3e50;
                margin-bottom: 10px;
            }

            .container {
                display: flex;
                gap: 20px;
                background: white;
                padding: 20px;
                border-radius: 15px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            }

            canvas {
                border: 2px solid #333;
                border-radius: 4px;
                cursor: crosshair;
            }

            .controls {
                width: 250px;
                display: flex;
                flex-direction: column;
                gap: 15px;
            }

            .btn {
                padding: 12px;
                font-size: 16px;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                transition: transform 0.1s;
            }

            .btn:active {
                transform: scale(0.98);
            }

            .btn-new {
                background-color: #3498db;
                color: white;
            }

            .btn-new:hover {
                background-color: #2980b9;
            }

            .btn-solve {
                background-color: #2ecc71;
                color: white;
            }

            .btn-solve:hover {
                background-color: #27ae60;
            }

            .info-panel {
                background: #ecf0f1;
                padding: 15px;
                border-radius: 8px;
                border-left: 5px solid #34495e;
            }

            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 5px;
                font-size: 14px;
            }

            .dot {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                margin-right: 8px;
            }

            .vocab-list {
                margin-top: 10px;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
    </head>

    <body>
        <h1>üèôÔ∏è City Directions Trainer</h1>

        <div class="container">
            <canvas id="cityCanvas" width="600" height="600"></canvas>

            <div class="controls">
                <button class="btn btn-new" onclick="generateScenario()">üé≤ New Scenario</button>
                <button class="btn btn-solve" onclick="togglePath()">üó∫Ô∏è Show/Hide Path</button>
            </div>
        </div>

        <script>
            const canvas = document.getElementById('cityCanvas');
            const ctx = canvas.getContext('2d');
            const gridSize = 10; // 10x10 grid
            const tileSize = 60; // pixel size of each tile

            // 0 = Road, 1 = Building
            // A handcrafted map to ensure good connectivity
            const mapLayout = [
                [1, 1, 1, 0, 1, 1, 0, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
                [0, 0, 1, 1, 0, 0, 0, 1, 0, 0],
                [1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 0, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 0, 1, 1, 0, 1, 1, 1]
            ];

            const buildings = [
                { x: 2, y: 3, name: 'Bakery', color: '#BBB0C1', icon: 'ü•ê' },
                { x: 3, y: 2, name: 'School', color: '#BBB0C1', icon: 'üè´' },
                { x: 3, y: 3, name: 'Gym', color: '#BBB0C1', icon: 'üèãÔ∏è' },
                { x: 2, y: 2, name: 'Library', color: '#BBB0C1', icon: 'üìö' },
                { x: 7, y: 2, name: 'Police', color: '#BBB0C1', icon: 'üëÆ' },
                { x: 2, y: 5, name: 'Park', color: '#BBB0C1', icon: 'üå≥' },
                { x: 7, y: 5, name: 'Cafe', color: '#BBB0C1', icon: '‚òï' },
                { x: 3, y: 5, name: 'Bank', color: '#BBB0C1', icon: 'üí∞' },
                { x: 2, y: 7, name: 'Hospital', color: '#BBB0C1', icon: 'üè•' },
                { x: 7, y: 3, name: 'Cinema', color: '#BBB0C1', icon: 'üé¨' },
                { x: 5, y: 5, name: 'Restaurant', color: '#BBB0C1', icon: 'üçΩÔ∏è' },
                { x: 7, y: 7, name: 'Zoo', color: '#BBB0C1', icon: 'ü¶í' },
                { x: 5, y: 4, name: 'Museum', color: '#BBB0C1', icon: 'üèõÔ∏è' },
                { x: 5, y: 4, name: 'University', color: '#BBB0C1', icon: 'üéì' },
                { x: 5, y: 2, name: 'Pharmacy', color: '#BBB0C1', icon: 'üíä' },
            ];

      let startPos = { x: 0, y: 0 };
      let endPos = { x: 0, y: 0 };
      let currentPath = [];
      let showingPath = false;

      function getRoadChar(x, y) {
        // Check neighbors: up, right, down, left
        const up = y > 0 && mapLayout[y - 1][x] === 0;
        const right = x < gridSize - 1 && mapLayout[y][x + 1] === 0;
        const down = y < gridSize - 1 && mapLayout[y + 1][x] === 0;
        const left = x > 0 && mapLayout[y][x - 1] === 0;

        // Count connections
        const connections = (up ? 1 : 0) + (right ? 1 : 0) + (down ? 1 : 0) + (left ? 1 : 0);

        // Determine character based on connections
        if (connections === 0) return ' '; // Isolated
        if (connections === 1) {
          if (up) return '‚ä•';
          if (down) return 'T';
          if (left) return '‚î´';
          if (right) return '‚î£';
        }
        if (connections === 2) {
          if ((up && down) || (left && right)) return '‚îÄ'; // Straight line
          if (up && right) return '‚îî';
          if (up && left) return '‚îò';
          if (down && right) return '‚îå';
          if (down && left) return '‚îê';
        }
        if (connections === 3) {
          if (!up) return 'T';
          if (!right) return '‚î´';
          if (!down) return '‚ä•';
          if (!left) return '‚î£';
        }
        if (connections === 4) return '‚îº'; // Crossroad
        return '‚îÄ';
      }

            function drawMap() {
                // Clear canvas (road color)
                ctx.fillStyle = '#354257';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw Roads with connectors
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (mapLayout[y][x] === 0) {
                            const bx = x * tileSize;
                            const by = y * tileSize;
                            const char = getRoadChar(x, y);
                            ctx.fillStyle = '#5a687d';
                            ctx.font = '28px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(char, bx + tileSize / 2, by + tileSize / 2);
                        }
                    }
                }

                // Draw Buildings
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (mapLayout[y][x] === 1) {
                            const bx = x * tileSize;
                            const by = y * tileSize;
                            const landmark = buildings.find((b) => b.y === y && b.x === x);
                            if (landmark) {
                                ctx.fillStyle = landmark.color;
                                ctx.fillRect(bx, by, tileSize, tileSize);
                                ctx.fillStyle = 'white';
                                ctx.font = '24px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(landmark.icon, bx + tileSize / 2, (by + tileSize / 2) - 5);

                                // Label
                                ctx.fillStyle = 'black';
                                ctx.font = '11px Arial';
                                ctx.fillText(landmark.name, bx + tileSize / 2, by + tileSize - 10);
                            } else {
                                // Generic building
                                ctx.fillStyle = '#BBB0C1';
                                ctx.fillRect(bx, by, tileSize, tileSize);
                                ctx.fillStyle = 'white';
                                ctx.font = '24px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('üè¢', bx + tileSize / 2, by + tileSize / 2);
                            }
                        }
                    }
                }

                // Draw Path if enabled
                if (showingPath && currentPath.length > 0) {
                    ctx.strokeStyle = 'rgba(46, 204, 113, 0.6)';
                    ctx.lineWidth = 8;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(startPos.x * tileSize + tileSize / 2, startPos.y * tileSize + tileSize / 2);
                    for (let p of currentPath) {
                        ctx.lineTo(p.x * tileSize + tileSize / 2, p.y * tileSize + tileSize / 2);
                    }
                    ctx.stroke();
                }

                // Draw Start and End markers
                drawMarker(startPos.x, startPos.y, 'Start', 'blue');
                drawMarker(endPos.x, endPos.y, 'End', 'red');
            }

            function drawMarker(x, y, text, color) {
                const px = x * tileSize + tileSize / 2;
                const py = y * tileSize + tileSize / 2;
                ctx.beginPath();
                ctx.arc(px, py, 10, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(text, px, py - 15);
            }

            function generateScenario() {
                showingPath = false;
                let valid = false;
                while (!valid) {
                    // Generate random coordinates
                    let sY = Math.floor(Math.random() * gridSize);
                    let sX = Math.floor(Math.random() * gridSize);
                    let eY = Math.floor(Math.random() * gridSize);
                    let eX = Math.floor(Math.random() * gridSize);

                    // Check 1: Must be on a road (0)
                    if (mapLayout[sY][sX] !== 0 || mapLayout[eY][eX] !== 0) continue;

                    // Check 2: Manhattan Distance > 5 (Not too close)
                    let distance = Math.abs(sY - eY) + Math.abs(sX - eX);
                    if (distance < 5) continue;

                    startPos = { x: sX, y: sY };
                    endPos = { x: eX, y: eY };

                    // Calculate path to ensure they are actually connected
                    currentPath = findPath(startPos, endPos);
                    if (currentPath.length > 0) valid = true;
                }
                drawMap();
            }

      function togglePath() {
        showingPath = !showingPath;
        drawMap();
      }            // Simple BFS Pathfinding
            function findPath(start, end) {
                let queue = [[start]];
                let visited = new Set();
                visited.add(start.y + ',' + start.x);
                while (queue.length > 0) {
                    let path = queue.shift();
                    let curr = path[path.length - 1];
                    if (curr.y === end.y && curr.x === end.x) return path;

                    const dirs = [
                        [0, 1],
                        [0, -1],
                        [1, 0],
                        [-1, 0]
                    ];

                    for (let d of dirs) {
                        let ny = curr.y + d[0];
                        let nx = curr.x + d[1];
                        if (
                            ny >= 0 &&
                            ny < gridSize &&
                            nx >= 0 &&
                            nx < gridSize &&
                            mapLayout[ny][nx] === 0 &&
                            !visited.has(ny + ',' + nx)
                        ) {
                            visited.add(ny + ',' + nx);
                            let newPath = [...path, { y: ny, x: nx }];
                            queue.push(newPath);
                        }
                    }
                }
                return [];
            }

            function getDirections(path) {
                if (path.length < 2) return 'No path.';
                let directions = [];
                let currentFacing = null;
                let straightSteps = 0;

                for (let i = 1; i < path.length; i++) {
                    let dx = path[i].x - path[i - 1].x;
                    let dy = path[i].y - path[i - 1].y;
                    let moveDir = getDir(dx, dy);
                    if (currentFacing === null) {
                        currentFacing = moveDir;
                        straightSteps = 1;
                    } else if (moveDir === currentFacing) {
                        straightSteps++;
                    } else {
                        directions.push(getStraightText(straightSteps));
                        let turn = getTurn(currentFacing, moveDir);
                        directions.push(`Turn ${turn}.`);
                        currentFacing = moveDir;
                        straightSteps = 1;
                    }
                }

                if (straightSteps > 0) {
                    directions.push(getStraightText(straightSteps));
                }
                directions.push("You've arrived!");
                return directions.join('\n');
            }

            function getDir(dx, dy) {
                if (dx === 1) return 1; // right
                if (dx === -1) return 3; // left
                if (dy === 1) return 2; // down
                if (dy === -1) return 0; // up
            }

            function getTurn(oldD, newD) {
                let diff = (newD - oldD + 4) % 4;
                if (diff === 1 || diff === -3) return 'right';
                if (diff === 3 || diff === -1) return 'left';
                if (diff === 2 || diff === -2) return 'around';
                return 'unknown';
            }

            function getStraightText(steps) {
                return `Go straight for ${steps} block${steps > 1 ? 's' : ''}.`;
            }

            // Initialize
            generateScenario();
        </script>
    </body>
</html>